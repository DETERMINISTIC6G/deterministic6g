<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="OMNeT++ NED doc generator"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
<link rel="stylesheet" href="material-icons.css">
<link rel="stylesheet" href="material.blue-light_blue.min.css">
<link rel="stylesheet" href="style.css" type="text/css" />

<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<title>Tcp</title>
</head>
<body>

<div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer mdl-layout--fixed-header">
  <header class="mdl-layout__header">
    <div id="top" class="mdl-layout__header-row">
      <span class="mdl-layout-title">Tcp</span>
      <div class="mdl-layout-spacer"></div>
<!--
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable">
        <label class="mdl-button mdl-js-button mdl-button--icon" for="search">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" id="search" />
          <label class="mdl-textfield__label" for="search">Enter your query...</label>
        </div>
      </div>
      <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons">code</i>
      </button>
      <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" id="hdrbtn">
        <i class="material-icons">more_vert</i>
      </button>
      <ul class="mdl-menu mdl-js-menu mdl-js-ripple-effect mdl-menu--bottom-right" for="hdrbtn">
        <li class="mdl-menu__item">OMNeT++ Website</li>
      </ul>
-->
    </div>
  </header>

  <div class="drawer mdl-layout__drawer">
    <nav id="side-nav" class="mdl-navigation">
      <div id="nav-tree">
        <div id="nav-tree-contents">
          <div id="nav-sync" class="sync"></div>
        </div>
      </div>
    </nav>
  </div>
  <script type="text/javascript">
  $(document).ready(function(){initNavTree(location.pathname.split("/").slice(-1).toString(),'');});
  </script>

  <main class="mdl-layout__content">
    <div id="doc-content">

    <p>Package: <a class="reference-ned" href="packages.html#inet_transportlayer_tcp">inet.transportlayer.tcp</a></p>
<h2 class="comptitle" style="float: left;">Tcp</h2>
<span class="mdl-chip" style="float: right; margin-top: 6pt; background-color: #ff000040;">
    <span class="mdl-chip__text">simple module</span>
</span><div style="clear: both;"/>

<p>TCP protocol implementation.
See the ~<a title="inet.transportlayer.contract.ITcp" href="inet.transportlayer.contract.ITcp.html">ITcp</a> for the <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> layer general informations.</p>
<p>This implementation supports:</p>
  <ul><li>RFC  793 - Transmission Control <a title="inet::Protocol" href="inet-Protocol.html">Protocol</a></li>
  <li>RFC  896 - Congestion Control in IP/TCP Internetworks</li>
  <li>RFC 1122 - Requirements for Internet Hosts -- Communication Layers</li>
  <li>RFC 1323 - TCP Extensions for High Performance</li>
  <li>RFC 2018 - TCP Selective Acknowledgment Options</li>
  <li>RFC 2581 - TCP Congestion Control</li>
  <li>RFC 2883 - An Extension to the Selective Acknowledgement (SACK) Option for TCP</li>
  <li>RFC 3042 - Enhancing TCP's Loss Recovery Using Limited Transmit</li>
  <li>RFC 3390 - Increasing TCP's Initial Window</li>
  <li>RFC 3517 - A Conservative Selective Acknowledgment (SACK)-based Loss Recovery
               Algorithm for TCP</li>
  <li>RFC 3782 - The NewReno Modification to TCP's Fast Recovery Algorithm</li></ul>
<p>This module is compatible with both ~<a title="inet.networklayer.ipv4.Ipv4" href="inet.networklayer.ipv4.Ipv4.html">Ipv4</a> and ~<a title="inet.networklayer.ipv6.Ipv6" href="inet.networklayer.ipv6.Ipv6.html">Ipv6</a>.</p>
<p>A TCP segment is represented by the class ~<a title="inet::tcp::TcpHeader" href="inet-tcp-TcpHeader.html">TcpHeader</a>.</p>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Communication with clients&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
<p>For communication between client applications and TCP, the ~<a title="inet::TcpCommandCode" href="inet-TcpCommandCode.html">TcpCommandCode</a>
and ~<a title="inet::TcpStatusInd" href="inet-TcpStatusInd.html">TcpStatusInd</a> enums are used as message kinds, and ~<a title="inet::TcpCommand" href="inet-TcpCommand.html">TcpCommand</a>
and its subclasses are used as control info.</p>
<p>To open a connection from a client app, send a cMessage to TCP with
TCP_C_OPEN_ACTIVE as message kind and a ~<a title="inet::TcpOpenCommand" href="inet-TcpOpenCommand.html">TcpOpenCommand</a> object filled in
and attached to it as control info. (The peer <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> will have to be LISTENing;
the server app can achieve this with a similar cMessage but TCP_C_OPEN_PASSIVE
message kind.) With passive open, there's a possibility to cause the connection
"fork" on an incoming connection, leaving the original connection LISTENing
on the port (see the fork field in ~<a title="inet::TcpOpenCommand" href="inet-TcpOpenCommand.html">TcpOpenCommand</a>).</p>
<p>The client app can send data by assigning the TCP_C_SEND message kind to the data packet,
and sending it to TCP. The server app will receive data as messages
with the TCP_I_DATA message kind.</p>
<p>To close, the client sends a cMessage to TCP with the TCP_C_CLOSE message kind
and ~<a title="inet::TcpCommand" href="inet-TcpCommand.html">TcpCommand</a> control info.</p>
<p><a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> sends notifications to the application whenever there's a significant
change in the state of the connection: established, remote TCP closed,
closed, timed out, connection refused, connection reset, etc. These
notifications are also cMessages with message kind TCP_I_xxx
(TCP_I_ESTABLISHED, etc.) and ~<a title="inet::TcpCommand" href="inet-TcpCommand.html">TcpCommand</a> as control info.</p>
<p>One TCP module can serve several application modules, and several
connections per application. When talking to applications, a
connection is identified by the socketId that is assigned by the application in
the OPEN call.</p>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Sockets&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
<p>The TcpSocket <a title="inet.examples.ospfv2.fulltest.C" href="inet.examples.ospfv2.fulltest.C.html">C</a>++ class is provided to simplify managing <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> connections
from applications. TcpSocket handles the job of assembling and sending
command messages (OPEN, CLOSE, etc) to TCP, and it also simplifies
the task of dealing with packets and notification messages coming from <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a>.</p>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Communication with the IP layer&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
<p>The TCP model relies on sending and receiving ~<a title="inet::L3AddressReq" href="inet-L3AddressReq.html">L3AddressReq</a>/~<a title="inet::L3AddressInd" href="inet-L3AddressInd.html">L3AddressInd</a> tags
attached to TCP segment packets.</p>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Configuring TCP&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
  <ol><li>use the module parameter (limitedTransmitEnabled) to enabled/disabled
     Limited Transmit algorithm (RFC 3042) integrated to TcpBaseAlg
     (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
     for DumbTcp).</li>
  <li>use the module parameter (increasedIWEnabled) to change Initial Window
     from one segment (RFC 2001) (based on MSS) to maximal four segments
     (min(4*MSS, max (2*MSS, 4380 bytes))) (RFC 3390) integrated to
     TcpBaseAlg (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl
     but not for DumbTcp).</li></ol>
<p>The TCP flavour supported depends on the value of the tcpAlgorithmClass
module parameter, e.g. "TcpTahoe" or "TcpReno". In the future, other
classes can be written which implement Vegas, LinuxTcp (which
differs from others) or other variants.</p>
<p>Note that ~<a title="inet::TcpOpenCommand" href="inet-TcpOpenCommand.html">TcpOpenCommand</a> allows tcpAlgorithmClass to be chosen per-connection.</p>
<p>Notes:</p>
  <ul><li>if you do active OPEN, then send data and close before the connection
   has reached ESTABLISHED, the connection will go from SYN_SENT to CLOSED
   without actually sending the buffered data. This is consistent with
   RFC 793 but may not be what you'd expect.</li>
  <li>handling segments with SYN+FIN bits set (esp. with data too) is
   inconsistent across TCPs, so check this one if it's of importance</li></ul>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Standards&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
<p>The TCP module itself implements the following:</p>
  <ul><li>all RFC 793 TCP states and state transitions</li>
  <li>connection setup and teardown as in RFC 793</li>
  <li>generally, RFC 793 compliant segment processing</li>
  <li>all socked commands (except RECEIVE) and indications</li>
  <li>receive buffer to cache above-sequence data and data not yet forwarded
   to the user</li>
  <li>CONN-ESTAB timer, SYN-REXMIT timer, 2MSL timer, FIN-WAIT-2 timer</li>
  <li>The basic SACK implementation (RFC 2018 and RFC 2883) is located in
   TCP main (and not in flavours).
   This means that all existing TCP algorithm classes may be used with
   SACK, although currently only TcpReno makes sense.</li>
  <li>RFC 3517 - (SACK)-based Loss Recovery algorithm which is a conservative
   replacement of the fast recovery algorithm (RFC2581) integrated to
   TcpReno but not to TcpNewReno, TcpTahoe, TcpNoCongestionControl and DumbTcp.</li>
  <li>changes from RFC 2001 to RFC 2581:</li>
  <ul><li>ACK generation (ack_now = true) RFC 2581, page 6: "(...) a <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> receiver SHOULD send an immediate ACK
       when the incoming segment fills in all or part of a gap in the sequence space."</li></ul>
  <li>TCP header options:</li>
  <ul><li>EOL: End of option list.</li>
  <li>NOP: Padding bytes, currently needed for SACK_PERMITTED and SACK.</li>
  <li>MSS: The value of snd_mss (SMSS) is set to the minimum of snd_mss
       (local parameter) and the value specified in the MSS option
       received during connection startup. Based on [RFC 2581, page 1].</li>
  <li>WS: Window Scale option, based on RFC 1323.</li>
  <li>SACK_PERMITTED: SACK can only be used if both nodes sent SACK_-
       PERMITTED during connection startup.</li>
  <li>SACK: SACK option, based on RFC 2018, RFC 2883 and RFC 3517.</li>
  <li>TS: Timestamps option, based on RFC 1323.</li></ul>
  <li>flow control: finite receive buffer size (initiated by parameter
   advertisedWindow). If receive buffer is exhausted (by out-of-order
   segments) and the payload length of a new received segment
   is higher than free receiver buffer, the new segment will be dropped.
   Such drops are recorded in tcpRcvQueueDropsVector.</li></ul>
<p>The TcpNewReno, TcpReno and TcpTahoe algorithms implement:</p>
  <ul><li>RFC 1122 - delayed ACK algorithm (optional) with 200ms timeout</li>
  <li>RFC 896 - Nagle's algorithm (optional)</li>
  <li>Jacobson's and Karn's algorithms for round-trip time measurement and
   adaptive retransmission</li>
  <li>TcpTahoe (Fast Retransmit), TcpReno (Fast Retransmit and Fast Recovery), TcpNewReno (Fast Retransmit and Fast Recovery)</li>
  <li>RFC 3390 - Increased Initial Window (optional) integrated to TcpBaseAlg
   (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
   for DumbTcp).</li>
  <li>RFC 3042 - Limited Transmit algorithm (optional) integrated to TcpBaseAlg
   (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
   for DumbTcp).</li></ul>
<p>Missing bits:</p>
  <ul><li>URG and PSH bits not handled. Receiver always acts as if PSH was set
   on all segments: always forwards data to the app as soon as possible.</li>
  <li>no RECEIVE command. Received data are always forwarded to the app as
   soon as possible, as if the app issued a very large RECEIVE request
   at the beginning. This means there's currently no flow control
   between <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a> and the app.</li>
  <li>all timeouts are precisely calculated: timer granularity (which is caused
   by "slow" and "fast" i.e. 500ms and 200ms timers found in many *nix <a title="inet.transportlayer.tcp.Tcp" href="inet.transportlayer.tcp.Tcp.html">Tcp</a>
   implementations) is not simulated</li>
  <li>new ECN flags (CWR and ECE). Need to be added to header by [RFC 3168].</li></ul>
<p>TcpNewReno/TcpReno/TcpTahoe issues and missing features:</p>
  <ul><li>KEEP-ALIVE not implemented (idle connections never time out)</li>
  <li>Nagle's algorithm (RFC 896) possibly not precisely implemented</li></ul>
<p>The above problems are relatively easy to fix, and will be resolved in the
next iteration. Also, other TCPAlgorithms will be added.</p>
<p>&lt;<a title="inet::b" href="inet-b.html">b</a>&gt;Tests&lt;/<a title="inet::b" href="inet-b.html">b</a>&gt;</p>
<p>There are automated test cases (*.test files) for TCP -- see the <i>tests</i>
directory in the source distribution.</p>
<p>Please also see ChangeLog.</p>
<img src="inet.transportlayer.tcp.Tcp-type.svg" ismap="yes" usemap="#type-diagram"/><map name="type-diagram">
<area shape="rect" href="inet.transportlayer.tcp.Tcp.html" title="Tcp" alt="Tcp" coords="0,42,76,82">
</map>
<h3 class="subtitle">Inheritance diagram</h3>
<p>The following diagram shows inheritance relationships for this type.
Unresolved types are missing from the diagram.</p>
<object type="image/svg+xml" data="inet.transportlayer.tcp.Tcp-inheritance.svg"></object>
<h3 class="subtitle">Parameters</h3>
<table class="paramstable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Type</th>
      <th class="defaultvalue">Default value</th>
      <th class="description">Description</th>
   </tr>
   <tr class="local">
      <td>crcMode</td>
      <td>string</td>
      <td>"declared"</td>
      <td></td>
   </tr>
   <tr class="local">
      <td>advertisedWindow</td>
      <td>int</td>
      <td>14*this.mss</td>
      <td>
<p>in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)</p>
</td>
   </tr>
   <tr class="local">
      <td>delayedAcksEnabled</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>delayed ACK algorithm (RFC 1122) enabled/disabled</p>
</td>
   </tr>
   <tr class="local">
      <td>nagleEnabled</td>
      <td>bool</td>
      <td>true</td>
      <td>
<p>Nagle's algorithm (RFC 896) enabled/disabled</p>
</td>
   </tr>
   <tr class="local">
      <td>limitedTransmitEnabled</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl)</p>
</td>
   </tr>
   <tr class="local">
      <td>increasedIWEnabled</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>Increased Initial Window (RFC 3390) enabled/disabled</p>
</td>
   </tr>
   <tr class="local">
      <td>sackSupport</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)</p>
</td>
   </tr>
   <tr class="local">
      <td>windowScalingSupport</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)</p>
</td>
   </tr>
   <tr class="local">
      <td>windowScalingFactor</td>
      <td>int</td>
      <td>-1</td>
      <td>
<p>Window Scaling Factor to the power of 2. -1 indicates that manual window scaling is turned off.</p>
</td>
   </tr>
   <tr class="local">
      <td>timestampSupport</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)</p>
</td>
   </tr>
   <tr class="local">
      <td>mss</td>
      <td>int</td>
      <td>536</td>
      <td>
<p>Maximum Segment Size (RFC 793) (header option)</p>
</td>
   </tr>
   <tr class="local">
      <td>msl</td>
      <td>int</td>
      <td>120s</td>
      <td>
<p>Maximum Segment Lifetime</p>
</td>
   </tr>
   <tr class="local">
      <td>tcpAlgorithmClass</td>
      <td>string</td>
      <td>"TcpReno"</td>
      <td></td>
   </tr>
   <tr class="local">
      <td>useDataNotification</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>turn the notifications for arrived data on or off</p>
</td>
   </tr>
   <tr class="local">
      <td>dupthresh</td>
      <td>int</td>
      <td>3</td>
      <td>
<p>used for TcpTahoe, TcpReno and SACK (RFC 3517) DO NOT change unless you really know what you are doing</p>
</td>
   </tr>
   <tr class="local">
      <td>initialSsthresh</td>
      <td>int</td>
      <td>0xFFFFFFFF</td>
      <td>
<p>initial value for Slow Start threshold used in TahoeRenoFamily. The initial value of ssthresh SHOULD be set arbitrarily high (e.g.,to the size of the largest possible advertised window) Without user interaction there is no limit...</p>
</td>
   </tr>
   <tr class="local">
      <td>stopOperationExtraTime</td>
      <td>double</td>
      <td>0s</td>
      <td>
<p>extra time after lifecycle stop operation finished</p>
</td>
   </tr>
   <tr class="local">
      <td>stopOperationTimeout</td>
      <td>double</td>
      <td>2s</td>
      <td>
<p>timeout value for lifecycle stop operation</p>
</td>
   </tr>
   <tr class="local">
      <td>ecnWillingness</td>
      <td>bool</td>
      <td>false</td>
      <td>
<p>true if willing to use ECN</p>
</td>
   </tr>
   <tr class="local">
      <td>dctcpGamma</td>
      <td>double</td>
      <td>0.0625</td>
      <td>
<p>A fixed estimation gain for calculating dctcp_alpha (RFC 8257 4.2)</p>
</td>
   </tr>
</table>
<h3 class="subtitle">Properties</h3>
<table class="propertiestable">
   <tr>
      <th class="name">Name</th>
      <th class="value">Value</th>
      <th class="description">Description</th>
   </tr>
   <tr>
      <td>display</td>
      <td>i=block/wheelbarrow</td>
      <td></td>
   </tr>
</table>
<h3 class="subtitle">Gates</h3>
<table class="gatestable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Direction</th>
      <th class="gatesize">Size</th>
      <th class="description">Description</th>
   </tr>
   <tr class="local">
      <td>appIn</td>
      <td>input</td>
      <td></td>
      <td></td>
   </tr>
   <tr class="local">
      <td>ipIn</td>
      <td>input</td>
      <td></td>
      <td></td>
   </tr>
   <tr class="local">
      <td>appOut</td>
      <td>output</td>
      <td></td>
      <td></td>
   </tr>
   <tr class="local">
      <td>ipOut</td>
      <td>output</td>
      <td></td>
      <td></td>
   </tr>
</table>
<h3 class="subtitle">Signals</h3>
<table class="signalstable">
   <tr>
      <th class="name">Name</th>
      <th class="type">Type</th>
      <th class="unit">Unit</th>
   </tr>
   <tr class="local">
      <td>tcpConnectionAdded</td>
      <td></td>
      <td></td>
   </tr>
   <tr class="local">
      <td>tcpConnectionRemoved</td>
      <td></td>
      <td></td>
   </tr>
   <tr class="local">
      <td>packetReceivedFromUpper</td>
      <td>cPacket</td>
      <td></td>
   </tr>
   <tr class="local">
      <td>packetReceivedFromLower</td>
      <td>cPacket</td>
      <td></td>
   </tr>
   <tr class="local">
      <td>packetDropped</td>
      <td>inet::Packet</td>
      <td></td>
   </tr>
</table>
<h3 class="subtitle">Source code</h3>
<pre class="src">
<span style="color: #808080; font-style: italic; ">//
// TCP protocol implementation.
// See the ~ITcp for the Tcp layer general informations.
//
// This implementation supports:
//   - RFC  793 - Transmission Control Protocol
//   - RFC  896 - Congestion Control in IP/TCP Internetworks
//   - RFC 1122 - Requirements for Internet Hosts -- Communication Layers
//   - RFC 1323 - TCP Extensions for High Performance
//   - RFC 2018 - TCP Selective Acknowledgment Options
//   - RFC 2581 - TCP Congestion Control
//   - RFC 2883 - An Extension to the Selective Acknowledgement (SACK) Option for TCP
//   - RFC 3042 - Enhancing TCP's Loss Recovery Using Limited Transmit
//   - RFC 3390 - Increasing TCP's Initial Window
//   - RFC 3517 - A Conservative Selective Acknowledgment (SACK)-based Loss Recovery
//                Algorithm for TCP
//   - RFC 3782 - The NewReno Modification to TCP's Fast Recovery Algorithm
//
// This module is compatible with both ~Ipv4 and ~Ipv6.
//
// A TCP segment is represented by the class ~TcpHeader.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Communication with clients</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// For communication between client applications and TCP, the ~TcpCommandCode
// and ~TcpStatusInd enums are used as message kinds, and ~TcpCommand
// and its subclasses are used as control info.
//
// To open a connection from a client app, send a cMessage to TCP with
// TCP_C_OPEN_ACTIVE as message kind and a ~TcpOpenCommand object filled in
// and attached to it as control info. (The peer Tcp will have to be LISTENing;
// the server app can achieve this with a similar cMessage but TCP_C_OPEN_PASSIVE
// message kind.) With passive open, there's a possibility to cause the connection
// &quot;fork&quot; on an incoming connection, leaving the original connection LISTENing
// on the port (see the fork field in ~TcpOpenCommand).
//
// The client app can send data by assigning the TCP_C_SEND message kind to the data packet,
// and sending it to TCP. The server app will receive data as messages
// with the TCP_I_DATA message kind.
//
// To close, the client sends a cMessage to TCP with the TCP_C_CLOSE message kind
// and ~TcpCommand control info.
//
// Tcp sends notifications to the application whenever there's a significant
// change in the state of the connection: established, remote TCP closed,
// closed, timed out, connection refused, connection reset, etc. These
// notifications are also cMessages with message kind TCP_I_xxx
// (TCP_I_ESTABLISHED, etc.) and ~TcpCommand as control info.
//
// One TCP module can serve several application modules, and several
// connections per application. When talking to applications, a
// connection is identified by the socketId that is assigned by the application in
// the OPEN call.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Sockets</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// The TcpSocket C++ class is provided to simplify managing Tcp connections
// from applications. TcpSocket handles the job of assembling and sending
// command messages (OPEN, CLOSE, etc) to TCP, and it also simplifies
// the task of dealing with packets and notification messages coming from Tcp.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Communication with the IP layer</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// The TCP model relies on sending and receiving ~L3AddressReq/~L3AddressInd tags
// attached to TCP segment packets.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Configuring TCP</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
//   -# use the module parameter (limitedTransmitEnabled) to enabled/disabled
//      Limited Transmit algorithm (RFC 3042) integrated to TcpBaseAlg
//      (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
//      for DumbTcp).
//
//   -# use the module parameter (increasedIWEnabled) to change Initial Window
//      from one segment (RFC 2001) (based on MSS) to maximal four segments
//      (min(4*MSS, max (2*MSS, 4380 bytes))) (RFC 3390) integrated to
//      TcpBaseAlg (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl
//      but not for DumbTcp).
//
// The TCP flavour supported depends on the value of the tcpAlgorithmClass
// module parameter, e.g. &quot;TcpTahoe&quot; or &quot;TcpReno&quot;. In the future, other
// classes can be written which implement Vegas, LinuxTcp (which
// differs from others) or other variants.
//
// Note that ~TcpOpenCommand allows tcpAlgorithmClass to be chosen per-connection.
//
// Notes:
//  - if you do active OPEN, then send data and close before the connection
//    has reached ESTABLISHED, the connection will go from SYN_SENT to CLOSED
//    without actually sending the buffered data. This is consistent with
//    RFC 793 but may not be what you'd expect.
//  - handling segments with SYN+FIN bits set (esp. with data too) is
//    inconsistent across TCPs, so check this one if it's of importance
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Standards</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// The TCP module itself implements the following:
//  - all RFC 793 TCP states and state transitions
//  - connection setup and teardown as in RFC 793
//  - generally, RFC 793 compliant segment processing
//  - all socked commands (except RECEIVE) and indications
//  - receive buffer to cache above-sequence data and data not yet forwarded
//    to the user
//  - CONN-ESTAB timer, SYN-REXMIT timer, 2MSL timer, FIN-WAIT-2 timer
//  - The basic SACK implementation (RFC 2018 and RFC 2883) is located in
//    TCP main (and not in flavours).
//    This means that all existing TCP algorithm classes may be used with
//    SACK, although currently only TcpReno makes sense.
//  - RFC 3517 - (SACK)-based Loss Recovery algorithm which is a conservative
//    replacement of the fast recovery algorithm (RFC2581) integrated to
//    TcpReno but not to TcpNewReno, TcpTahoe, TcpNoCongestionControl and DumbTcp.
//  - changes from RFC 2001 to RFC 2581:
//      - ACK generation (ack_now = true) RFC 2581, page 6: &quot;(...) a Tcp receiver SHOULD send an immediate ACK
//        when the incoming segment fills in all or part of a gap in the sequence space.&quot;
//  - TCP header options:
//      - EOL: End of option list.
//      - NOP: Padding bytes, currently needed for SACK_PERMITTED and SACK.
//      - MSS: The value of snd_mss (SMSS) is set to the minimum of snd_mss
//        (local parameter) and the value specified in the MSS option
//        received during connection startup. Based on [RFC 2581, page 1].
//      - WS: Window Scale option, based on RFC 1323.
//      - SACK_PERMITTED: SACK can only be used if both nodes sent SACK_-
//        PERMITTED during connection startup.
//      - SACK: SACK option, based on RFC 2018, RFC 2883 and RFC 3517.
//      - TS: Timestamps option, based on RFC 1323.
//  - flow control: finite receive buffer size (initiated by parameter
//    advertisedWindow). If receive buffer is exhausted (by out-of-order
//    segments) and the payload length of a new received segment
//    is higher than free receiver buffer, the new segment will be dropped.
//    Such drops are recorded in tcpRcvQueueDropsVector.
//
// The TcpNewReno, TcpReno and TcpTahoe algorithms implement:
//  - RFC 1122 - delayed ACK algorithm (optional) with 200ms timeout
//  - RFC 896 - Nagle's algorithm (optional)
//  - Jacobson's and Karn's algorithms for round-trip time measurement and
//    adaptive retransmission
//  - TcpTahoe (Fast Retransmit), TcpReno (Fast Retransmit and Fast Recovery), TcpNewReno (Fast Retransmit and Fast Recovery)
//  - RFC 3390 - Increased Initial Window (optional) integrated to TcpBaseAlg
//    (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
//    for DumbTcp).
//  - RFC 3042 - Limited Transmit algorithm (optional) integrated to TcpBaseAlg
//    (can be used for TcpNewReno, TcpReno, TcpTahoe and TcpNoCongestionControl but not
//    for DumbTcp).
//
// Missing bits:
//  - URG and PSH bits not handled. Receiver always acts as if PSH was set
//    on all segments: always forwards data to the app as soon as possible.
//  - no RECEIVE command. Received data are always forwarded to the app as
//    soon as possible, as if the app issued a very large RECEIVE request
//    at the beginning. This means there's currently no flow control
//    between Tcp and the app.
//  - all timeouts are precisely calculated: timer granularity (which is caused
//    by &quot;slow&quot; and &quot;fast&quot; i.e. 500ms and 200ms timers found in many *nix Tcp
//    implementations) is not simulated
//  - new ECN flags (CWR and ECE). Need to be added to header by [RFC 3168].
//
// TcpNewReno/TcpReno/TcpTahoe issues and missing features:
//  - KEEP-ALIVE not implemented (idle connections never time out)
//  - Nagle's algorithm (RFC 896) possibly not precisely implemented
//
// The above problems are relatively easy to fix, and will be resolved in the
// next iteration. Also, other TCPAlgorithms will be added.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Tests</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// There are automated test cases (*.test files) for TCP -- see the </span><span style="color: #800000; ">&lt;i&gt;</span><span style="color: #808080; font-style: italic; ">tests</span><span style="color: #800000; ">&lt;/i&gt;</span><span style="color: #808080; font-style: italic; ">
// directory in the source distribution.
//
// Please also see ChangeLog.
//
</span><span style="color: #800000; font-weight: bold; ">simple</span><span style="color: #232629; "> </span><span style="color: #232629; ">Tcp</span><span style="color: #232629; "> </span><span style="color: #800000; font-weight: bold; ">like</span><span style="color: #232629; "> </span><span style="color: #232629; ">ITcp</span><span style="color: #232629; ">
{
    </span><span style="color: #800000; font-weight: bold; ">parameters</span><span style="color: #232629; ">:
        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #232629; "> </span><span style="color: #232629; ">crcMode</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@enum</span><span style="color: #232629; ">(</span><span style="color: #008000; ">&quot;declared&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;computed&quot;</span><span style="color: #232629; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">&quot;declared&quot;</span><span style="color: #232629; ">);
        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">advertisedWindow</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">14</span><span style="color: #232629; ">*</span><span style="color: #800000; font-weight: bold; ">this</span><span style="color: #232629; ">.</span><span style="color: #232629; ">mss</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">delayedAcksEnabled</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// delayed ACK algorithm (RFC 1122) enabled/disabled
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">nagleEnabled</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">true</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Nagle's algorithm (RFC 896) enabled/disabled
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">limitedTransmitEnabled</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">increasedIWEnabled</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Increased Initial Window (RFC 3390) enabled/disabled
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">sackSupport</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">windowScalingSupport</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">windowScalingFactor</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(-</span><span style="color: #008000; ">1</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Window Scaling Factor to the power of 2. -1 indicates that manual window scaling is turned off.
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">timestampSupport</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">mss</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">536</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// Maximum Segment Size (RFC 793) (header option)
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">msl</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@unit</span><span style="color: #232629; ">(</span><span style="color: #232629; ">s</span><span style="color: #232629; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">120</span><span style="color: #232629; ">s</span><span style="color: #232629; ">);   </span><span style="color: #808080; font-style: italic; ">// Maximum Segment Lifetime
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #232629; "> </span><span style="color: #232629; ">tcpAlgorithmClass</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@enum</span><span style="color: #232629; ">(</span><span style="color: #008000; ">&quot;TcpVegas&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;TcpWestwood&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;TcpNewReno&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;TcpReno&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;TcpTahoe&quot;</span><span style="color: #232629; ">,</span><span style="color: #008000; ">&quot;TcpNoCongestionControl&quot;</span><span style="color: #232629; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">&quot;TcpReno&quot;</span><span style="color: #232629; ">);
        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">useDataNotification</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// turn the notifications for arrived data on or off
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">dupthresh</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">3</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// used for TcpTahoe, TcpReno and SACK (RFC 3517) DO NOT change unless you really know what you are doing
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #232629; "> </span><span style="color: #232629; ">initialSsthresh</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">0</span><span style="color: #232629; ">xFFFFFFFF</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// initial value for Slow Start threshold used in TahoeRenoFamily. The initial value of ssthresh SHOULD be set arbitrarily high (e.g.,to the size of the largest possible advertised window) Without user interaction there is no limit...
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">double</span><span style="color: #232629; "> </span><span style="color: #232629; ">stopOperationExtraTime</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@unit</span><span style="color: #232629; ">(</span><span style="color: #232629; ">s</span><span style="color: #232629; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">0</span><span style="color: #232629; ">s</span><span style="color: #232629; ">);    </span><span style="color: #808080; font-style: italic; ">// extra time after lifecycle stop operation finished
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">double</span><span style="color: #232629; "> </span><span style="color: #232629; ">stopOperationTimeout</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@unit</span><span style="color: #232629; ">(</span><span style="color: #232629; ">s</span><span style="color: #232629; ">) = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">2</span><span style="color: #232629; ">s</span><span style="color: #232629; ">);    </span><span style="color: #808080; font-style: italic; ">// timeout value for lifecycle stop operation
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #232629; "> </span><span style="color: #232629; ">ecnWillingness</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">false</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// true if willing to use ECN
</span><span style="color: #232629; ">        </span><span style="color: #000080; font-weight: bold; ">double</span><span style="color: #232629; "> </span><span style="color: #232629; ">dctcpGamma</span><span style="color: #232629; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #232629; ">(</span><span style="color: #008000; ">0</span><span style="color: #232629; ">.</span><span style="color: #008000; ">0625</span><span style="color: #232629; ">); </span><span style="color: #808080; font-style: italic; ">// A fixed estimation gain for calculating dctcp_alpha (RFC 8257 4.2)
</span><span style="color: #232629; ">        </span><span style="color: #232629; font-weight: bold; ">@display</span><span style="color: #232629; ">(</span><span style="color: #008000; ">&quot;i=block/wheelbarrow&quot;</span><span style="color: #232629; ">);
        </span><span style="color: #232629; font-weight: bold; ">@signal</span><span style="color: #232629; ">[</span><span style="color: #232629; ">tcpConnectionAdded</span><span style="color: #232629; ">];
        </span><span style="color: #232629; font-weight: bold; ">@signal</span><span style="color: #232629; ">[</span><span style="color: #232629; ">tcpConnectionRemoved</span><span style="color: #232629; ">];
        </span><span style="color: #232629; font-weight: bold; ">@signal</span><span style="color: #232629; ">[</span><span style="color: #232629; ">packetReceivedFromUpper</span><span style="color: #232629; ">](</span><span style="color: #232629; ">type</span><span style="color: #232629; ">=</span><span style="color: #232629; ">cPacket</span><span style="color: #232629; ">);
        </span><span style="color: #232629; font-weight: bold; ">@signal</span><span style="color: #232629; ">[</span><span style="color: #232629; ">packetReceivedFromLower</span><span style="color: #232629; ">](</span><span style="color: #232629; ">type</span><span style="color: #232629; ">=</span><span style="color: #232629; ">cPacket</span><span style="color: #232629; ">);
        </span><span style="color: #232629; font-weight: bold; ">@signal</span><span style="color: #232629; ">[</span><span style="color: #232629; ">packetDropped</span><span style="color: #232629; ">](</span><span style="color: #232629; ">type</span><span style="color: #232629; ">=</span><span style="color: #232629; ">inet</span><span style="color: #232629; ">::</span><span style="color: #232629; ">Packet</span><span style="color: #232629; ">);
    </span><span style="color: #800000; font-weight: bold; ">gates</span><span style="color: #232629; ">:
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #232629; "> </span><span style="color: #232629; ">appIn</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@labels</span><span style="color: #232629; ">(</span><span style="color: #232629; ">TcpCommand</span><span style="color: #232629; ">/</span><span style="color: #232629; ">down</span><span style="color: #232629; ">) </span><span style="color: #232629; font-weight: bold; ">@messageKinds</span><span style="color: #232629; ">(</span><span style="color: #232629; ">inet</span><span style="color: #232629; ">::</span><span style="color: #232629; ">TcpCommandCode</span><span style="color: #232629; ">);
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #232629; "> </span><span style="color: #232629; ">ipIn</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@labels</span><span style="color: #232629; ">(</span><span style="color: #232629; ">TcpHeader</span><span style="color: #232629; ">,</span><span style="color: #232629; ">Ipv4ControlInfo</span><span style="color: #232629; ">/</span><span style="color: #232629; ">up</span><span style="color: #232629; ">,</span><span style="color: #232629; ">Ipv6ControlInfo</span><span style="color: #232629; ">/</span><span style="color: #232629; ">up</span><span style="color: #232629; ">);
        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #232629; "> </span><span style="color: #232629; ">appOut</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@labels</span><span style="color: #232629; ">(</span><span style="color: #232629; ">TcpCommand</span><span style="color: #232629; ">/</span><span style="color: #232629; ">up</span><span style="color: #232629; ">) </span><span style="color: #232629; font-weight: bold; ">@messageKinds</span><span style="color: #232629; ">(</span><span style="color: #232629; ">inet</span><span style="color: #232629; ">::</span><span style="color: #232629; ">TcpStatusInd</span><span style="color: #232629; ">);
        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #232629; "> </span><span style="color: #232629; ">ipOut</span><span style="color: #232629; "> </span><span style="color: #232629; font-weight: bold; ">@labels</span><span style="color: #232629; ">(</span><span style="color: #232629; ">TcpHeader</span><span style="color: #232629; ">,</span><span style="color: #232629; ">Ipv4ControlInfo</span><span style="color: #232629; ">/</span><span style="color: #232629; ">down</span><span style="color: #232629; ">,</span><span style="color: #232629; ">Ipv6ControlInfo</span><span style="color: #232629; ">/</span><span style="color: #232629; ">down</span><span style="color: #232629; ">);
}

</span></pre>
File: <a href="src-inet-transportlayer-tcp-Tcp.ned.html">src/inet/transportlayer/tcp/Tcp.ned</a>
<hr><p class="footer"><a href="http://creativecommons.org/licenses/by-sa/3.0" target="_top"><img src="by-sa.svg"></a> This documentation is released under the <a href="http://creativecommons.org/licenses/by-sa/3.0" target="_top">Creative Commons license</a></p>


    </div><!-- doc-content -->
  </main>
</div>

<script type="text/javascript" src="material.min.js"></script>
</body>
</html>
