[General]
sim-time-limit = 30s
seed-set = 918273
description = "Tutorial 2"
network = d6g.simulations.training_day.tutorial2.NetworkSolution2

**.hasOutgoingStreams = true
*.listener.numApps = 2
*.listener.app[*].typename = "UdpSinkApp"
*.listener.app[0].io.localPort = 1042
*.listener.app[1].io.localPort = 1043

**.streamIdentifier.identifier.mapping = [{stream: "stream1", packetFilter: expr(udp.destPort == 1042)},
                                          {stream: "stream2", packetFilter: expr(udp.destPort == 1043)}]

**.streamCoder.*.mapping = [{stream: "stream1", pcp: 7},
						    {stream: "stream2", pcp: 6}]

**.numTrafficClasses = 8

[Task1]
extends = General
*.talker1.numApps = 1
*.talker1.hasOutgoingStreams = true
*.talker1.app[*].typename = "UdpSourceApp"
*.talker1.app[*].display-name = "stream1"
*.talker1.app[*].io.destAddress = "listener"
*.talker1.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker1.app[0].io.destPort = 1042
*.talker1.app[0].source.productionInterval = 10ms

# Task 1a)
# This task only takes place in the network_tutorial2.ned file.
# Your task is to change the type of the detCom device to a DetCom node.
# 
# Make yourself familiar with the structure of the DetCom node:
# https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.devices.DetCom.html
# 
# The listener should be connected to the network side of the simulator.
# All other devices should be connected as wireless devices.

# Task 1b)
# Confirm that your network works as intended.
# 1. Run the simulation
# 2. Create an .anf file and generate a graph that shows the end to end delay (meanBitLifetimePerPacket) of each packet.


[Task2]
extends = Task1

*.talker2.numApps = 1
*.talker2.hasOutgoingStreams = true
*.talker2.app[*].typename = "UdpSourceApp"
*.talker2.app[*].display-name = "stream2"
*.talker2.app[*].io.destAddress = "listener"
*.talker2.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker2.app[0].io.destPort = 1043
*.talker2.app[0].source.productionInterval = 10ms
*.talker2.app[0].source.initialProductionOffset = 2.5ms

# As you saw in the previous task, the end-to-end delay is static.
# Delays within the DetCom node are typically variable.

# Task 2a)
# Your task is to setup the uplink delay in the DetCom node.
# - The connection of talker1 should use a given Histogram as a delay source.
# 	Use uplink_given.xml (you can see a plot of it in uplink_given.png, it has a mean delay of 5.6ms)
# - The connection of talker2 should experience a normal distribution with the following parameters o=2.5ms, u=100us in the DetCom node
# 
# The following documentation might be helpful:
# - Setting up delays in the DetCom node:
# 	https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.devices.tsntranslator.TsnTranslator.html
# - Reading Histogram files:
# 	https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.distribution.histogram.HistogramContainer.html
# 	The NED function to draw delays from the Histogram: quantity rngProvider(string rngProviderModule, string key?) 
# 		(Example usage here: https://deterministic6g.github.io/deterministic6g/doc/simulations/edgecloud/doc/index.html )
# Task 2b)
# 1. Run the simulation
# 2. In your .anf file, create two Histogram figures showing the end-to-end delays for both streams
# 3. Make sure the Histograms match your expectations (compare the outcoming Histogram with uplink_given.png and the expected normal distribution)

[Task3a]
extends = Task2

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[7].offset = 10ms - 16.10us - 5.6ms # cycle time - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[7].durations = [10us, 9990us]
*.bridge.eth[1].macLayer.queue.transmissionGate[6].offset = 10ms + 2.5ms - 16.10us - 2.5ms # cycle time + production offset - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[6].durations = [10us, 9990us]

# You are now given a schedule that works for wired network.
# ---------------------------------------------------------
# For reference, we have a 8.050us packet delay per Ethernet
# link (8us = 100byte/100Mbps, 50ns propagation). Hence, 
# talker -> detCom: 	[0us, 		8.050us]
# detCom -> bridge: 	[8.050us, 	16.100us]
# bridge -> listener: 	[16.100us,	24.150us]
# ---------------------------------------------------------
# The schedule is configured to use the mean delays of the
# distributions from Task 2. We want to explore what happens
# if the same techniques are used for wireless TSN.
# Task 3a)
# 1. Execute the simulation
# 2. Explore the resulting end-to-end delays. What do you discover?
# 3. In which scenarios could this phenomenon result in violations of the 
#    QoS requirements? This about how to fix this problem.

[Task3b]
extends = Task2

**.streamCoder.*.mapping = [{stream: "stream1", pcp: 7},
						    {stream: "stream2", pcp: 7}]

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[7].offset = 4.3839ms
*.bridge.eth[1].macLayer.queue.transmissionGate[7].durations = [10us, 5.59ms, 10us, 4.39ms]

# The approach of Task 3a does not scale, as it would require one egress queue per TSN stream.
# (Note that TSN bridges have a limit of 8 FIFO queues per egress port)
# For this reason, we now want to merge the GCLs of both egress queues into one.
# Task 3b)
# 1. Execute the simulation
# 2. Explore the resulting end-to-end delays. What do you discover?
# 3. Would your fix of Task3a help to fix this problem? Explain why or why not.
# 4. What mechanism of Lecture 1 could be used to mitigate this problem? 
#    How would this mechanism affect the QoS guarantees.
